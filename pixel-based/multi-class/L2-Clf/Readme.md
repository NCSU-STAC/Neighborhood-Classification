### L2 classification per pixel {informal vs formal vs background}
* Please note, you have to change paths to point to data on your machines in each file.
* ipython notebook does the grid search and saves models to disk. To run this, simply navigate to this folder, and open the file using jupyter notebook.
* Model generation is being done separately in another file (generate_training_models*.py) since the machine we were using for hyperparameter search and the machine we were using for inference (prediction across entire image) do not have the same versions of necessary software. To run this file, just say ```python generate_training...```. This code will also print the accuracies on the sample test data.
* classifyImage.py - to classify section of the entire image - takes a range of rows, (starting row, ending row) - will classify this section. To run this, say ```python classifyImage.py starting_row_number ending_row_number```. You can also do this on regions of interest by clipping the image and changing paths to the new raster in the code.
* To classify the entire image, we use predict.c which is an MPI based solution (this was run on NCSU's ARC cluster to generate results in distributed manner). predict.c calls several worker nodes, each of which is given a starting_row_number and an ending_row_number. Each worker then calls classifyImage.py with these starting and ending row numbers. Each worker classifies the section of image within their corresponding starting and ending row numbers and write them to disk as numpy arrays. We then use the scripts from postprocessing to combine these classification outcomes. Please note that this code can only run if you have an MPi-enabled distributed cluster such as ARC from NCSU.
